Agora, a pr√°tica
Vamos juntar tudo o que aprendemos at√© aqui e exercitar mais ainda nosso aprendizado!
Considera√ß√µes MacOS
Se voc√™ est√° utilizando MacOS, por favor, leias essas considera√ß√µes. Caso contr√°rio, pode seguir adiante para os exerc√≠cios.
Conforme explicado na aula ao vivo, como o uso avan√ßado de firewalls √© mais comum em servidores, sendo esses mais comuns estarem utilizando linux ou windows, demos uma aten√ß√£o maior ao iptables , que provavelmente ser√° o firewall com o qual iremos lidar no nosso dia-a-dia.
Por√©m, n√£o podemos te deixar de fora da pr√°tica! Sendo assim, iremos passar um passo a passo sobre como voc√™ ir√° configurar uma m√°quina Linux no seu computador atrav√©s do docker . Para come√ßar, voc√™ precisa de instalar o docker no seu computador. Para isso, utilize o comando brew para auxiliar:
Copiar
$ brew install --cask docker
Em seguida, execute o aplicativo do docker , que foi instalado na sua m√°quina atrav√©s do brew , d√™ privilegio para o docker passando a sua senha e pronto! O docker j√° est√° rodando! Para testar, execute o comando abaixo:
Copiar
$ docker ps
Tudo certo at√© ent√£o? Agora rode o comando abaixo para subir uma m√°quina Linux com a distro ubuntu 20.4 . Estamos passando a tag --privileged para que voc√™ consiga executar os comandos dos exerc√≠cios sem problemas de permiss√£o de host :
Copiar
$ docker run --privileged -p 8000:8000 -it ubuntu:20.04 bash
Beleza, com a m√°quina Linux rodando, execute os comandos abaixo para instalar o iptables , o ping e o traceroute :
Copiar
$ apt-get update && apt-get install iputils-ping

$ apt-get update && apt-get install traceroute

$ apt-get update && apt-get install iptables
Agora rode os comandos abaixo para testar se est√° tudo certo:
Copiar
$ ping google.com

$ traceroute google.com

$ iptables -L
Se algum deles n√£o funcionar, reinicie o docker atrav√©s do √≠cone na barra de tarefas, pr√≥ximo √† data e hora do computador. Em seguida, teste novamente.
Feito tudo isso, voc√™ j√° tem uma m√°quina linux sendo executada no seu computador e j√° est√° apta ou apto a fazer os exerc√≠cios abaixo!
Exerc√≠cios
Agora vamos colocar em pr√°tica todo o conte√∫do que vimos. Para isso faremos alguns exerc√≠cios pr√°ticos utilizando nossos conhecimentos sobre firewall.
Exerc√≠cio 1 : Defina uma regra de firewall utilizando o comando iptables -A , que bloqueie ( block ou REJECT/DROP ) toda a entrada ( in ou INPUT ) de pacotes utilizando o protocolo ICMP , impedindo assim que a m√°quina responda ao comando ping . Lembre-se, voc√™ pode executar o comando ping para validar se sua regra est√° funcionando corretamente: ping 127.0.0.1 (voc√™ pode adicionar o par√¢metro -O para exibir os pings rejeitados tamb√©m üòâ).
Exerc√≠cio 2 : Exclua a regra anterior utilizando o par√¢metro -D .
Exerc√≠cio 3 : Agora vamos criar uma regra para bloquear o tr√°fego HTTPS. Para isso, iremos bloquear a sa√≠da de pacotes ( out ou OUTPUT ). Lembre-se, a porta padr√£o para esse protocolo √© a 443 , para especific√°-la utilize o par√¢metro --sport . Ele utiliza tamb√©m o protocolo tcp . Para testar sua regra, tente acessar um site pelo navegador que use o protocolo, como o Youtube, o Google ou o Facebook.
Exerc√≠cio 4 : Bloqueie agora o tr√°fego de sa√≠da para HTTP. Lembre-se, tamb√©m √© utilizado o protocolo tcp e a porta 80 . Para testar sua regra, tente acessar um site pelo navegador que use HTTP .
Exerc√≠cio 5 : Para finalizar, vamos limpar todas as regras. Para isso, utilize o comando --flush do iptables (Linux).
Exerc√≠cio 6 : Agora, vamos utilizar um tipo de proxy bem legal que pode ser bastante √∫til no nosso dia como pessoas desenvolvedoras: o NGROK . Com ele conseguimos criar um t√∫nel para o nosso localhost .
Crie um servidor HTTP em sua m√°quina executando na porta 80 , pode ser um front-end ou um back-end criado em aulas anteriores.
Baixe o ngrok e extraia o arquivo baixado em uma pasta de sua prefer√™ncia, conforme instru√ß√µes no site oficial .
Conforme instru√ß√µes do site, crie um t√∫nel para a porta 80 de sua m√°quina.
Acesse o o link disponibilizado em seu navegador. Utilize ele para acessar de outros dispositivos, como seu smartphone ou outro computador üòé.

Exerc√≠cio 7 : No conte√∫do vimos o que s√£o os protocolos SSL e TLS. Vamos subir nosso pr√≥prio servidor HTTPS, utilizando nosso pr√≥prio certificado!
Vamos utilizar a ferramenta OpenSSL para gerar nossos certificados. Ela j√° vem instalada na maioria das distros Linux. No Docker, no entanto, voc√™ vai precisar executar:
Copiar
$ apt-get update && apt-get install python3 openssl
Para gerar nosso pr√≥prio certificado auto-assinado, utilize os comandos abaixo. Lembrando que, como n√≥s estamos gerando o certificado, ele n√£o ser√° reconhecido por nenhuma entidade certificadora, de modo que ele s√≥ nos servir√° para utilizar o protocolo TLS com o HTTPS, n√£o sendo capaz de ser aceito pelo navegador.
Copiar
$ openssl genrsa -out key.pem
$ openssl req -new -key key.pem -out csr.pem
$ openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem
$ rm csr.pem
Acabamos de gerar dois arquivos, o cert.pem (o certificado) e o key.pem (chave privada). Copie os dois arquivos para um diret√≥rio onde iremos criar nosso servidor HTTPS.
Agora vamos escrever um servidor https usando os m√≥dulos nativos do python ssl e http.server . Embora esses m√≥dulos tenham muitos muitos recursos (muitos mesmo), n√≥s vamos usar apenas alguns. Tente seguir as instru√ß√µes a seguir:
4.1 Crie um contexto SSL com a classe SSLContext , usando o protocolo de vers√£o mais alta dispon√≠vel para servidores. (dica: as op√ß√µes est√£o listadas na documenta√ß√£o). 4.2 Carregue no contexto SSL a cadeia de certifica√ß√£o, passando tanto a o arquivo de certifica√ß√£o quanto a sua chave. (dica: existe um m√©todo para isso). 4.3 Crie uma inst√¢ncia de HTTPServer . O endere√ßo deve ser uma tupla ('localhost', 8000) e para responder as requisi√ß√µes, use SimpleHTTPRequestHandler . (dica: apesar do exemplo na documenta√ß√£o, n√£o use with .) 4.4 Crie um socket server-side usando o m√©todo wrap_socket do seu contexto SSL. Passe como par√¢metro o socket do servidor ( server.socket ). 4.5 Substitua o socket do servidor pelo socket que vc acabou de criar. 4.6 Execute o servidor com o m√©todo serve_forever .
Acesse o servidor no endere√ßo https://localhost:8000/ utilizando o Firefox (precisa ser o Firefox!). Perceba que ele ir√° informar que o certificado n√£o √© reconhecido por ele, pois n√£o foi assinado por nenhuma autoridade da confian√ßa dele.
5.1 Chrome e Safari se recusam a acessar um site cujo certificado n√£o est√° assinado por NENHUMA autoridade certificadora (existem instru√ß√µes para agir como uma autoridade certificadora mas n√£o precisa seguir por esse caminho).
Acesse o servidor novamente, por√©m, desta vez utilizando cURL (de fora do Docker, se vc estiver usando).
Por √∫ltimo, vamos utilizar um recurso do cURL, somente para testes (somente utilize, caso realmente voc√™ esteja esperando por aquilo), que √© o par√¢metro -k ou --insecure . Com ele, falamos para o nosso cURL prosseguir a request mesmo sabendo que a conex√£o n√£o √© "confi√°vel".





Gabarito dos exerc√≠cios
A seguir, encontram-se sugest√µes de solu√ß√µes para os exerc√≠cios propostos.
Exerc√≠cio 1 : Defina uma regra de firewall utilizando o comando iptables -A que bloqueie ( block ou REJECT/DROP ) toda a entrada ( in ou INPUT ) de pacotes utilizando o protocolo ICMP , impedindo assim que a m√°quina responda ao comando ping . Lembre-se, voc√™ pode executar o comando ping para validar se sua regra est√° funcionando corretamente: ping 127.0.0.1 (voc√™ pode adicionar o par√¢metro -O para exibir os pings rejeitados tamb√©m üòâ).
Copiar
$ iptables -A INPUT -p icmp -j REJECT
Exerc√≠cio 2 : Exclua a regra anterior utilizando o par√¢metro -D (Linux).
Copiar
$ iptables -D INPUT -p icmp -j REJECT
Exerc√≠cio 3 : Agora vamos criar uma regra para bloquear o tr√°fego HTTPS. Para isso iremos bloquear a sa√≠da de pacotes ( out ou OUTPUT ). Lembre-se, a porta padr√£o para esse protocolo √© a 443 , para especific√°-la utilize o par√¢metro --sport (Linux), ele utiliza tamb√©m o protocolo tcp . Para testar sua regra, tente acessar um site pelo navegador que use o protocolo, como o Youtube, o Google ou o Facebook (via curl, se estiver rodando no docker).
Copiar
$ iptables -A OUTPUT -p tcp --sport 443 -j REJECT
Exerc√≠cio 4 : Bloqueie agora o tr√°fego de sa√≠da para HTTP. Lembre-se, tamb√©m √© utilizado o protocolo tcp e a porta 80 . Para testar sua regra, tente acessar um site pelo navegador que use HTTP .
Copiar
$ iptables -A OUTPUT -p tcp --sport 80 -j REJECT
Exerc√≠cio 5 : Para finalizar, vamos limpar todas as regras. Para isso, utilize o comando --flush do iptables (Linux).
Copiar
$ iptables --flush
Exerc√≠cio 6 : Agora, vamos utilizar um tipo de proxy bem legal que pode ser bastante √∫til no nosso dia como pessoas desenvolvedoras o NGROK , com ele conseguimos criar um t√∫nel para o nosso localhost .
Crie um servidor HTTP em sua m√°quina executando na porta 80 , pode ser um frontend ou um backend criado em aulas anteriores.
Python √© um brinquedo que vem com todos os acess√≥rios, lembra? Claro que ele vem com um servidor http pronto pra usar! Vamos criar um diret√≥rio novo e rodar o servidor l√° dentro!
Copiar
$ mkdir diretorio && cd diretorio
$ python3 -m http.server 80
Baixe o ngrok e extraia o arquivo baixado em uma pasta de sua prefer√™ncia, conforme instru√ß√µes no site oficial .
Copiar
$ unzip /path/to/ngrok.zip
Conforme instru√ß√µes do site, crie um t√∫nel para a porta 80 de sua m√°quina.
Copiar
$ ./ngrok http 80
Acesse o o link disponibilizado em seu navegador. Utilize ele para acessar de outros dispositivos, como seu smartphone ou outro computador üòé.
Copiar
$ ./ngrok http 80
Exerc√≠cio 7 : No conte√∫do vimos o que s√£o os protocolos SSL e TLS, vamos subir nosso pr√≥prio servidor HTTPS, utilizando nosso pr√≥prio certificado.
Vamos utilizar a ferramenta OpenSSL para gerar nossos certificados. Ela j√° vem instalada na maioria das distros Linux. No Docker, no entanto, voc√™ vai precisar executar:
Copiar
$ apt-get update && apt-get install python3 openssl
Pra conferir se est√° instalado:
Copiar
$ openssl -v
Para gerar nosso pr√≥prio certificado auto-assinado, utilize os comandos abaixo. Lembrando que como n√≥s estamos gerando o certificado, ele n√£o ser√° reconhecido por nenhuma entidade certificadora, de modo que ele s√≥ nos servir√° para utilizar o protocolo TLS com o HTTPS, n√£o sendo capaz de ser aceito pelo navegador, por exemplo, que n√£o ir√° aceit√°-lo, por n√£o ter sido aprovado por nenhuma entidade reconhecida por ele.
Copiar
$ openssl genrsa -out key.pem
$ openssl req -new -key key.pem -out csr.pem
$ openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem
$ rm csr.pem
Acabamos de gerar dois arquivos, o cert.pem (o certificado) e o key.pem (chave privada). Copie os dois arquivos para um diret√≥rio onde iremos criar nosso servidor HTTPS.
Copiar
$ mkdir /some-dir/https-server
$ mv key.pem /some-dir/https-server
$ mv cert.pem /some-dir/https-server
$ cd /some-dir/https-server
Agora vamos escrever um servidor https usando os m√≥dulos nativos do python ssl e http.server . Embora esses m√≥dulos tenham muitos muitos recursos (muitos mesmo), n√≥s vamos usar apenas alguns. Tente seguir as instru√ß√µes a seguir:
4.1 Crie um contexto SSL com a classe SSLContext , usando o protocolo de vers√£o mais alta dispon√≠vel para servidores. (dica: as op√ß√µes est√£o listadas na documenta√ß√£o). 4.2 Carregue no contexto SSL a cadeia de certifica√ß√£o, passando tanto a o arquivo de certifica√ß√£o quanto a sua chave. (dica: existe um m√©todo para isso). 4.3 Crie uma inst√¢ncia de HTTPServer . O endere√ßo deve ser uma tupla ('localhost', 8000) e para responder as requisi√ß√µes, use SimpleHTTPRequestHandler . (dica: apesar do exemplo na documenta√ß√£o, n√£o use with .) 4.4 Crie um socket server-side usando o m√©todo wrap_socket do seu contexto SSL. Passe como par√¢metro o socket do servidor ( server.socket ). 4.5 Substitua o socket do servidor pelo socket que vc acabou de criar. 4.6 Execute o servidor com o m√©todo serve_forever .
https.py
Copiar
import ssl
from http.server import HTTPServer, SimpleHTTPRequestHandler

ssl_context = ssl.SSLContext()
ssl_context.load_cert_chain("cert.pem", keyfile="key.pem")

server_address = ("0.0.0.0", 8000)
httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
httpd.socket = ssl_context.wrap_socket(httpd.socket, server_side=True)

httpd.serve_forever()
Acesse o servidor utilizando o navegador. Perceba que ele ir√° informar que o certificado n√£o √© reconhecido por ele, pois n√£o foi assinado por nenhuma entidade da confian√ßa dele.
Acesse o servidor novamente, por√©m, desta vez utilizando cURL (de fora do Docker, se vc estiver usando).
Copiar
$ curl https://localhost:8000
Por √∫ltimo, vamos utilizar um recurso do cURL, somente para testes (somente utilize, caso realmente voc√™ esteja esperando por aquilo), que √© o par√¢metro -k ou --insecure . Com ele, falamos para o nosso cURL prosseguir a request mesmo sabendo que a conex√£o n√£o √© "confi√°vel".
Copiar
$ curl --insecure https://localhost:8000